# Kubernetes Documentation  
## 1. Persistent Volumes:
- A PV is a cluster resource representing actual storage (like a disk, NFS share, or cloud disk) provisioned by an admin or dynamically via a storage class.
- PVs exist independently of the lifecycle of individual pods; the data remains available even if pods are deleted or rescheduled.
- PVs use volume plugins and can be backed by various providers—local storage, network-attached storage (NFS, iSCSI), or cloud solutions (AWS EBS, Azure Disk).
* This is a first stage in storage where we have a storage in local but we have to make out of that storage a persistent volume
```yml
kind: PersistentVolume
apiVersion: v1
metadata:
  name: local-pv
  namespace: nginx
  labels: 
   app: local
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  hostPath:
    path: /mnt/data

```
```bash
kubectl apply -f persistent-volume.yml
kubectl get pv -n nginx
```
## 2. Persistent Volumes Claim:
- A PVC is a user's request for storage specifying size, access mode (like ReadWriteOnce, ReadOnlyMany), and sometimes storage class.
- PVCs abstract the storage request away from implementation, making it easy for users to request specific storage without knowing its details.
- When a PVC is created, Kubernetes tries to bind it to a suitable PV matching the requested parameters.
* This is used to link / bound the pvc to pv.
```yml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-pvc
  namespace: nginx
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: local-storage

```
```bash
kubectl apply -f perisistent-volume-claim.yml
kubectl get pvc -n nginx
```
* After this above stages we have to mention the mountvolume and volumes in yml of deployment to alocate the storage to that node.
```yml
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nginx-deployment
  namespace: nginx
spec:
  replicas: 2
  selector:
     matchLabels:
       app: nginx

  template:
    metadata:
      name: nginx-dep-pod
      labels:
         app: nginx

    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - mountPath: /var/www/html
          name: my-volume
      volumes:
        - name: my-volume
          persistentVolumeClaim:
            claimName: local-pvc

```
```bash
kubectl apply -f deployment.yml
```
> NOTE : if you want to check then use exec command to get into the container of docker of that working node and see the lacation.

* Using this the data will not lost even if the container / pod get deleted.

## 3. Services  
The Pods are running over the server but it is not expose to user for using it so for that services help to create a service and using port forwadding we can use that on our localhost.

### What are Kubernetes Services?

- Services group a set of Pods and provide a stable network endpoint to access them.
- They use label selectors to determine which Pods belong to the Service.
- Services enable load balancing and service discovery inside or outside the cluster.

### Types of Kubernetes Services

| Service Type  | Description                                                                                          | Use Case                                     | Accessibility         |
|---------------|--------------------------------------------------------------------------------------------------|----------------------------------------------|-----------------------|
| **ClusterIP** | Default Service type providing an internal IP accessible only within the cluster.                  | Internal communication between Pods          | Internal only         |
| **NodePort**  | Exposes the Service on a static port on each Node's IP, enabling external access via `<NodeIP>:<Port>`. | Development, testing, simple external access | External via Node IP  |
| **LoadBalancer** | Creates an external cloud load balancer that routes traffic to the Service.                      | Production-grade external access             | External with LB      |
| **ExternalName** | Maps the Service to an external DNS name, without proxying or load balancing.                   | Access external services transparently       | External DNS          |
| **Headless**  | Service with no ClusterIP, returning Pod IPs directly for stateful apps or direct Pod access.      | Stateful apps needing direct Pod communication| Internal, no LB       |

### How Services Work

- A client sends a request to the Service’s stable IP or DNS name.
- The Service routes the request to one of the backend Pods based on selectors.
- This mechanism provides load balancing and high availability as Pods scale or change.

```yml
kind: Service
apiVersion: v1
metadata:
  name: nginx-service
  namespace: nginx
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
```

```bash
kubectl apply -f service.yml
kubectl get service -n nginx
kubectl get all -n nginx
Sudo E kubectl port-forward service/nginx-service -n nginx 80:80 --address=0.0.0.0
```
## 4. Project For practice:
* Step-1: Clone the Git repository Project and use a dev branch for this project.
```bash
git clone git@github.com:LondheShubham153/django-notes-app.git
```
* Step-2: Build the image and upload it to docker hub.
```bash
docker build -t notes-app-k8s
docker image tag notes-app-k8s:latest avesh03767/notes-app-k8s:latest
docker push avesh03767/notes-app-k8s:latest
```
* Ste-3: Make a Deployment , namespace and service yml file
- make k8s folder and keep this yml files in this
- namespace.yml
```yml
kind: Namespace
apiVersion: v1
metadata:
  name: notes-app
```
- deployment.yml
```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: notes-app-deployment
  labels:
    app: notes-app
  namespace: notes-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: notes-app
  template:
    metadata:
      labels:
        app: notes-app
    spec:
      containers:
      - name: notes-app
        image: avesh03767/notes-app-k8s
        ports:
        - containerPort: 8000
```
- services.yml
```yml
kind: Service
apiVersion: v1
metadata:
  name: notes-app-service
  namespace: notes-app
spec:
  selector:
    app: notes-app
  ports:
    - protocol: TCP
      port: 8000
      targetPort: 8000
  type: ClusterIP
```
```bash
kubectl apply -f namespace.yml
kubectl apply -f deployment.yml
kubectl apply -f service.yml
kubectl get pods -n notes-app
kubectl port-forward service/notes-app-service -n notes-app 8000:8000 --address=0.0.0.0
```

* Thats good to go Open `http://localhost:8000`

## 5. Ingress: 
* Re routing and trafic management  
* Ingress in Kubernetes is an API object that manages external access to services in a cluster, typically HTTP/HTTPS routes. It provides routing rules to handle traffic from outside the cluster and forward it to the appropriate backend services.
### Ingress controller
* An Ingress Controller in Kubernetes is a specialized load balancer that implements the rules defined in Ingress resources. It listens to the Kubernetes API for Ingress objects and ensures the configured routing policies are applied to direct external HTTP(S) traffic to the correct internal services.

```bash
kubectl apply -f https://kind.sigs.k8s.io/examples/ingress/deploy-ingress-nginx.yaml
```
* To get ingress yml files which are important for ingress
* ingress yml file made.
```yml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-notes-ingress
  namespace: nginx
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - pathType: Prefix
        path: /nginx
        backend:
          service:
            name: nginx-service
            port:
              number: 80
      - pathType: Prefix
        path: /
        backend:
          service:
            name: notes-app-service
            port:
              number: 8000
```
* Also changes made in the deployment and service of notes app
* deployment.yml
```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: notes-app-deployment
  labels:
    app: notes-app
  namespace: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: notes-app
  template:
    metadata:
      labels:
        app: notes-app
    spec:
      containers:
      - name: notes-app
        image: avesh03767/notes-app-k8s
        ports:
        - containerPort: 8000
```
* service.yml 
```yml
kind: Service
apiVersion: v1
metadata:
  name: notes-app-service
  namespace: nginx
spec:
  selector:
    app: notes-app
  ports:
    - protocol: TCP
      port: 8000
      targetPort: 8000
  type: ClusterIP
```
* both the services are running on same namespace so one is nginx and other is notesapp so making a commomn using annotation and ingress controller
```bash
kubectl apply -f ingress.yml
kubectl get ingress -n nginx
kubectl get service -n ingress-nginx
sudo -E kubectl port-forward service/ingress-nginx-controller -n ingress-nginx 80:80 --address=0.0.0.0
```
## 5. Annotations:
* annotations are key-value pairs used to attach non-identifying metadata to objects such as Pods, Services, Deployments, or Ingresses. Unlike labels, annotations do not affect the behavior of the system in terms of selecting or grouping objects but provide additional context or configuration information that tools, libraries, or humans can use.
```yml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-notes-ingress
  namespace: nginx
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - pathType: Prefix
        path: /nginx
        backend:
          service:
            name: nginx-service
            port:
              number: 80
      - pathType: Prefix
        path: /
        backend:
          service:
            name: notes-app-service
            port:
              number: 8000
```
## Statefull set
* Run applications that must keep data or identity persistent across restarts and rescaling, like databases or storage systems.
### stateless set
* Run applications that do not keep or depend on any data from previous interactions. They can be freely recreated or scaled without losing any data.

* so for practicing this we have created a new namespace and trying mysql 
* namespace.yml
```yml
kind: Namespace
apiVersion: v1
metadata:
  name: mysql
```
* servoce.yml
```yml
kind: Service
apiVersion: v1
metadata:
  name: mysql-service
  namespace: mysql
spec:
  clusterIP: None
  selector:
    app: mysql
  ports:
  - name: mysql 
    protocol: TCP
    port: 3306
    targetPort: 3306
```
* statefullset.yml
```yml
kind: StatefulSet
apiVersion: apps/v1
metadata:
  name: mysql-statefulset
  namespace: mysql

spec:
  serviceName: mysql-service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
     labels:
       app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: root
        - name: MYSQL_DATABASE
          value: devops
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
```
```bash
kubectl apply -f namespace.yml
kubectl apply -f service.yml
kubectl apply -f statefulset.yml
kubectl get pods -n mysql
kubectl exec -it mysql-statefulset-0 -n mysql -- bash
kubectl delete pod mysql-statefulset-0 -n mysql
kubectl get pods -n mysql
```
* after this you will see that it is creating a same name pod after delete but data is consistent. 
