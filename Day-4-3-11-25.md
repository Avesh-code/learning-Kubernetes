# Kubernetes Documentation  
## 1. Persistent Volumes:
- A PV is a cluster resource representing actual storage (like a disk, NFS share, or cloud disk) provisioned by an admin or dynamically via a storage class.
- PVs exist independently of the lifecycle of individual pods; the data remains available even if pods are deleted or rescheduled.
- PVs use volume plugins and can be backed by various providers—local storage, network-attached storage (NFS, iSCSI), or cloud solutions (AWS EBS, Azure Disk).
* This is a first stage in storage where we have a storage in local but we have to make out of that storage a persistent volume
```yml
kind: PersistentVolume
apiVersion: v1
metadata:
  name: local-pv
  namespace: nginx
  labels: 
   app: local
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  hostPath:
    path: /mnt/data

```
```bash
kubectl apply -f persistent-volume.yml
kubectl get pv -n nginx
```
## 2. Persistent Volumes Claim:
- A PVC is a user's request for storage specifying size, access mode (like ReadWriteOnce, ReadOnlyMany), and sometimes storage class.
- PVCs abstract the storage request away from implementation, making it easy for users to request specific storage without knowing its details.
- When a PVC is created, Kubernetes tries to bind it to a suitable PV matching the requested parameters.
* This is used to link / bound the pvc to pv.
```yml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-pvc
  namespace: nginx
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: local-storage

```
```bash
kubectl apply -f perisistent-volume-claim.yml
kubectl get pvc -n nginx
```
* After this above stages we have to mention the mountvolume and volumes in yml of deployment to alocate the storage to that node.
```yml
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nginx-deployment
  namespace: nginx
spec:
  replicas: 2
  selector:
     matchLabels:
       app: nginx

  template:
    metadata:
      name: nginx-dep-pod
      labels:
         app: nginx

    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - mountPath: /var/www/html
          name: my-volume
      volumes:
        - name: my-volume
          persistentVolumeClaim:
            claimName: local-pvc

```
```bash
kubectl apply -f deployment.yml
```
> NOTE : if you want to check then use exec command to get into the container of docker of that working node and see the lacation.

* Using this the data will not lost even if the container / pod get deleted.

## 3. Services  
The Pods are running over the server but it is not expose to user for using it so for that services help to create a service and using port forwadding we can use that on our localhost.

### What are Kubernetes Services?

- Services group a set of Pods and provide a stable network endpoint to access them.
- They use label selectors to determine which Pods belong to the Service.
- Services enable load balancing and service discovery inside or outside the cluster.

### Types of Kubernetes Services

| Service Type  | Description                                                                                          | Use Case                                     | Accessibility         |
|---------------|--------------------------------------------------------------------------------------------------|----------------------------------------------|-----------------------|
| **ClusterIP** | Default Service type providing an internal IP accessible only within the cluster.                  | Internal communication between Pods          | Internal only         |
| **NodePort**  | Exposes the Service on a static port on each Node's IP, enabling external access via `<NodeIP>:<Port>`. | Development, testing, simple external access | External via Node IP  |
| **LoadBalancer** | Creates an external cloud load balancer that routes traffic to the Service.                      | Production-grade external access             | External with LB      |
| **ExternalName** | Maps the Service to an external DNS name, without proxying or load balancing.                   | Access external services transparently       | External DNS          |
| **Headless**  | Service with no ClusterIP, returning Pod IPs directly for stateful apps or direct Pod access.      | Stateful apps needing direct Pod communication| Internal, no LB       |

### How Services Work

- A client sends a request to the Service’s stable IP or DNS name.
- The Service routes the request to one of the backend Pods based on selectors.
- This mechanism provides load balancing and high availability as Pods scale or change.

```yml
kind: Service
apiVersion: v1
metadata:
  name: nginx-service
  namespace: nginx
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
```

```bash
kubectl apply -f service.yml
kubectl get service -n nginx
kubectl get all -n nginx
Sudo E kubectl port-forward service/nginx-service -n nginx 80:80 --address=0.0.0.0
```
## 4. Project For practice:
* Step-1: Clone the Git repository Project and use a dev branch for this project.
```bash
git clone git@github.com:LondheShubham153/django-notes-app.git
```
* Step-2: Build the image and upload it to docker hub.
```bash
docker build -t notes-app-k8s
docker image tag notes-app-k8s:latest avesh03767/notes-app-k8s:latest
docker push avesh03767/notes-app-k8s:latest
```
* Ste-3: Make a Deployment , namespace and service yml file
- make k8s folder and keep this yml files in this
- namespace.yml
```yml
kind: Namespace
apiVersion: v1
metadata:
  name: notes-app
```
- deployment.yml
```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: notes-app-deployment
  labels:
    app: notes-app
  namespace: notes-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: notes-app
  template:
    metadata:
      labels:
        app: notes-app
    spec:
      containers:
      - name: notes-app
        image: avesh03767/notes-app-k8s
        ports:
        - containerPort: 8000
```
- services.yml
```yml
kind: Service
apiVersion: v1
metadata:
  name: notes-app-service
  namespace: notes-app
spec:
  selector:
    app: notes-app
  ports:
    - protocol: TCP
      port: 8000
      targetPort: 8000
  type: ClusterIP
```
```bash
kubectl apply -f namespace.yml
kubectl apply -f deployment.yml
kubectl apply -f service.yml
kubectl get pods -n notes-app
kubectl port-forward service/notes-app-service -n notes-app 8000:8000 --address=0.0.0.0
```

* Thats good to go Open `http://localhost:8000`

