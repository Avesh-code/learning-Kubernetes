# Kubernetes Documentation  
## 1. Config Maps:
* ConfigMaps store normal data like settings or environment variables that are not secret. For example, a ConfigMap can keep the address of a database your app connects to. This helps keep your app code clean and separate from its settings.
* config.yml
```yml
kind: ConfigMap
apiVersion: v1
metadata:
  name: mysql-config-map
  namespace: mysql
data:
  MYSQL_DATABASE: devops
```
## 2. Secrets:
* Secrets store sensitive info like passwords, tokens, or keys in a safer way. They are encoded and Kubernetes tries to protect them better than ConfigMaps.
* secrets.yml
```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
  namespace: mysql
data:
  MYSQL_ROOT_PASSWORD: cm9vdAo=  #base64 encoded for root 
```
* this both used in Statefullset.yml
```yml
kind: StatefulSet
apiVersion: apps/v1
metadata:
  name: mysql-statefulset
  namespace: mysql

spec:
  serviceName: mysql-service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
     labels:
       app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_ROOT_PASSWORD
        - name: MYSQL_DATABASE
          valueFrom: 
           configMapKeyRef:
            name: mysql-config-map
            key: MYSQL_DATABASE
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
```

## 3. Resource Quotas and Limits :
* Resource Quotas in Kubernetes are like a budget set for each team or project in a Kubernetes cluster. They limit how much CPU, memory, and other resources a group can use in their own namespace.
* it is used in deployment.yml of nginx in spec and in containers you can see request and limits
```yml
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nginx-deployment
  namespace: nginx
spec:
  replicas: 2
  selector:
     matchLabels:
       app: nginx

  template:
    metadata:
      name: nginx-dep-pod
      labels:
         app: nginx

    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi

        volumeMounts:
        - mountPath: /usr/share/nginx/html
          name: my-volume
      volumes:
        - name: my-volume
          persistentVolumeClaim:
            claimName: local-pvc
```

## 4. Probes:
* In Kubernetes, probes are simple health checks for containers to make sure they are working properly. There are three types of probes:

| Probe Type      | Purpose                                                        | What Happens if It Fails                           | When to Use                                           |
|-----------------|----------------------------------------------------------------|---------------------------------------------------|------------------------------------------------------|
| **Liveness Probe**   | Checks if the container is alive and running                   | Kubernetes restarts the container                  | Detect if app hangs or crashes                        |
| **Readiness Probe**  | Checks if the container is ready to accept traffic            | Kubernetes stops sending requests to that container | When app needs time to be ready before serving traffic |
| **Startup Probe**    | Checks if the application inside the container has started    | Delays liveness and readiness probes until success | For apps that start slowly to avoid premature restarts |

Probes can check the health by:
- Running a command inside the container
- Sending an HTTP request to the container
- Trying to open a TCP connection

Kubernetes uses these probes to keep your apps stable and responsive inside the cluster.  
It is there in container spec livenessProbe:
* deployment.yml

```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: notes-app-deployment
  labels:
    app: notes-app
  namespace: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: notes-app
  template:
    metadata:
      labels:
        app: notes-app
    spec:
      containers:
      - name: notes-app
        image: avesh03767/notes-app-k8s
        ports:
        - containerPort: 8000
        livenessProbe:
          httpGet:
            path: /
            port: 8000
```
## 5. Taints and Tolerance
* Taints are applied to nodes. They act like a "warning" on the node saying, "I repel pods unless they tolerate me." If a node has a taint, no pods can run on it unless they have a matching toleration.
* Tolerations are applied to pods. They are like "exceptions" that allow the pod to be scheduled onto nodes with matching taints.


```yml
kind: Pod
apiVersion: v1
metadata:
  name: nginx-pod
  namespace: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
      ports:
        - containerPort: 80
  tolerations:
    - key: "prod"
      operator: "Equal"
      value: "true"
      effect: "NoSchedule" 
```
```bash
kubectl taint node avesh-cluster-worker prod=true:NoSchedule
kubectl taint node avesh-cluster-worker2 prod=true:NoSchedule
kubectl taint node avesh-cluster-worker3 prod=true:NoSchedule
# we have tainted all nodes so to run any pods on this node we should provide tolerance to that pods
Kubectl apply -f pod.yml
# if we want to make a untainted then just apply - at end
kubectl taint node avesh-cluster-worker prod=true:NoSchedule-
kubectl taint node avesh-cluster-worker2 prod=true:NoSchedule-
kubectl taint node avesh-cluster-worker3 prod=true:NoSchedule-
```
